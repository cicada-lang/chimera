Bit 0
Bit 1

find x {
  Bit x
}

BitXor [x, y, r] -- { x = 0  y = 0  r = 0 }
BitXor [x, y, r] -- { x = 0  y = 1  r = 1 }
BitXor [x, y, r] -- { x = 1  y = 0  r = 1 }
BitXor [x, y, r] -- { x = 1  y = 1  r = 0 }

find [x, y] {
  BitXor [x, y, 0]
}

find [x, y] {
  BitXor [x, y, 1]
}

find [x, y, r] {
  BitXor [x, y, r]
}

BitAnd [x, y, r] -- { x = 0  y = 0  r = 0 }
BitAnd [x, y, r] -- { x = 0  y = 1  r = 0 }
BitAnd [x, y, r] -- { x = 1  y = 0  r = 0 }
BitAnd [x, y, r] -- { x = 1  y = 1  r = 1 }

find [x, y] {
  BitAnd [x, y, 1]
}

// x + y = r + 2 * c

HalfAdder [x, y, r, c]
---------------------- {
  BitXor [x, y, r]
  BitAnd [x, y, c]
}

find r {
  HalfAdder [1, 1, r, 1]
}

find [x, y, r, c] {
  HalfAdder [x, y, r, c]
}

// b + x + y = r + 2 * c

FullAdder [b, x, y, r, c]
------------------------- {
  HalfAdder [x, y, w, xy]
  HalfAdder [w, b, r, wz]
  BitXor [xy, wz, c]
}

find [r, c] {
  FullAdder [0, 1, 1, r, c]
}

find [r, c] {
  FullAdder [1, 1, 1, r, c]
}

find [b, x, y, r, c] {
  FullAdder [b, x, y, r, c]
}

Pos n
---------------- {
  [a, ...d] = n
}

find q {
  Pos [0, 1, 1]
}

find q {
  Pos [1]
}

find q {
  Pos []
}

find r {
  Pos r
}

GreaterThanOne n
--------------------- {
  [a, ad, ...dd] = n
}

find q {
  GreaterThanOne [0, 1, 1]
}

find q {
  GreaterThanOne [0, 1]
}

find q {
  GreaterThanOne [1]
}

find q {
  GreaterThanOne []
}

find r {
  GreaterThanOne r
}

Adder [b, n, m, r]
----------------------- {
  0 = b  [] = m  n = r
}

Adder [b, n, m, r]
----------------------- {
  0 = b  [] = n  m = r
  Pos m
}

Adder [b, n, m, r]
----------------------- {
  1 = b  [] = m
  Adder [0, n, [1], r]
}

Adder [b, n, m, r]
----------------------- {
  1 = b  [] = n  Pos m
  Adder [0, [1], m, r]
}

Adder [b, n, m, r]
----------------------- {
  [1] = n  [1] = m
  [a, c] = r
  FullAdder [b, 1, 1, a, c]
}

Adder [b, n, m, r]
----------------------- {
  [1] = n
  GenAdder [b, n, m, r]
}

Adder [b, n, m, r]
----------------------- {
  [1] = m
  GreaterThanOne n
  GreaterThanOne r
  Adder [b, [1], n, r]
}

Adder [b, n, m, r]
----------------------- {
  GreaterThanOne n
  GenAdder [b, n, m, r]
}

// Given the carry bit b,
// and the numbers n, m, and r,
// `GenAdder` satisfies b + n + m = r,
// provided that n is positive
// and m and r are greater than one.

GenAdder [b, n, m, r]
------------------------- {
  [a, ...x] = n
  [d, ...y] = m  Pos y
  [c, ...z] = r  Pos z
  FullAdder [b, a, d, c, e]
  Adder [e, x, y, z]
}

find [x, y, r] limit 3 {
  Adder [0, x, y, r]
}

// find [x, y, r] limit 4 {
//   Adder [0, x, y, r]
// }

// find [x, y, r] limit 5 {
//   Adder [0, x, y, r]
// }

// find [x, y, r] limit 19 {
//   Adder [0, x, y, r]
// }

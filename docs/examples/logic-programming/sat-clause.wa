// We use `0` and `1`
// for `false` and `true`,
// because the code looks tidier.

Bit(x) -- { x = 0 }
Bit(x) -- { x = 1 }

Not(0, 1)
Not(1, 0)

Or(0, 0, 0)
Or(0, 1, 1)
Or(1, 0, 1)
Or(1, 1, 1)

BitList([])
BitList([car | cdr]) -- {
  Bit(car)
  BitList(cdr)
}

ListNot([], [])
ListNot([x | xs], [y | ys]) -- {
  Not(x, y)
  ListNot(xs, ys)
}

// A clause represent
//   c1 ∨ c2 ∨ ... <- p1 ∧ p2 ∧ ...
// which is equivalent to disjunction from
//   c1 ∨ c2 ∨ ... ¬p1 ∨ ¬p2 ∨ ...

Clause(conclusions, premises) -- {
  BitList(conclusions)
  BitList(premises)
  ListNot(premises, negPremises)
  Append(conclusions, negPremises, disjunction)
  // To satisfy a disjunction,
  // its element must contains a true,
  // specially empty list can not be satisfied.
  ContainsOne(disjunction)
}

ContainsOne([1 | _rest])
ContainsOne([0 | rest]) -- {
  ContainsOne(rest)
}

Append([], t, t)
Append([a | d], t, [a | res]) -- {
  Append(d, t, res)
}

find [x1, x2, x3] {
  Clause([x1], [x2])
  Clause([x2, x3], [x1])
  Clause([], [x1])
}

find [x1] {
  Clause([x1], [])
  Clause([], [x1])
}

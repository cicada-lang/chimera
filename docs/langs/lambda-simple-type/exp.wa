Exp(var(name)) -- { String(name) }
Exp(fn(name, ret)) -- { String(name) Exp(ret) }
Exp(ap(target, arg)) -- { Exp(target) Exp(arg) }

Type(atom(name)) -- { String(name) }
Type(arrow(argType, retType)) -- {
  Type(argType)
  Type(retType)
}

Ctx([])
Ctx([[name, type] | rest]) -- {
  String(name)
  Type(type)
  Ctx(rest)
}

Lookup([[key, value] | _rest], key, value)

Lookup([[key, _value] | rest], name, found)
-------------------------------------------- {
  key != name
  Lookup(rest, name, found)
}

Check(ctx, var(name), type)
---------------------------- {
  Lookup(ctx, name, type)
}

Check(ctx, fn(name, ret), arrow(argType, retType))
--------------------------------------------------- {
  Check([[name, argType] | ctx], ret, retType)
}

Check(ctx, ap(target, arg), retType)
------------------------------------- {
  Check(ctx, target, arrow(argType, retType))
  Check(ctx, arg, argType)
}

find type {
  ctx = []
  exp = fn("x", var("x"))
  Check(ctx, exp, type)
}

find exp limit 10 {
  ctx = []
  type = arrow("A", "A")
  Check(ctx, exp, type)
}

// (lambda (f) (f f)) can not type check,
// but empty list is the error message.
// see "miniKanren 2021 - Prolog-Style Meta-Programming miniKanren"
// - https://www.youtube.com/watch?v=09OyKjX4Sik
// for more about this.

assert not find type {
  ctx = []
  exp = fn("f", ap(var("f"), var("f")))
  Check(ctx, exp, type)
}

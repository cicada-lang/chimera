Exp Exp::var(name) -- { String name }
Exp Exp::fn(name, ret) -- { String name Exp ret }
Exp Exp::ap(target, arg) -- { Exp target Exp arg }

Type Type::atom(name) -- { String name }
Type Type::arrow(argType, retType) -- { Type argType Type retType }

Ctx []
Ctx [[name, type] | rest] -- { String name Type type Ctx rest }

Lookup [[[key, value] | _rest], key, value]

Lookup [[[key, _value] | rest], name, found]
------------------------------------------------------ {
  key != name
  Lookup [rest, name, found]
}

// TODO We need to understand and improve our search strategy
// to make the following perform the same as the above.

// Lookup [[[key, value] | rest], name, found]
// -------------------------------------------- {
//   disj {
//     conj { key = name found = value }
//     conj { key != name Lookup [rest, name, found] }
//   }
// }

Check [ctx, Exp::var(name), type]
---------------------------------- {
  Lookup [ctx, name, type]
}

Check [ctx, Exp::fn(name, ret), Type::arrow(argType, retType)]
---------------------------------------------------------------- {
  Check [[[name, argType] | ctx], ret, retType]
}

Check [ctx, Exp::ap(target, arg), retType]
----------------------------------------- {
  Check [ctx, target, Type::arrow(argType, retType)]
  Check [ctx, arg, argType]
}

find type {
  ctx = []
  exp = Exp::fn("x", Exp::var("x"))
  Check [ctx, exp, type]
}

find exp limit 10 {
  ctx = []
  type = Type::arrow("A", "A")
  Check [ctx, exp, type]
}

// (lambda (f) (f f)) can not type check,
// but empty list is the error message.
// see "miniKanren 2021 - Prolog-Style Meta-Programming miniKanren"
// - https://www.youtube.com/watch?v=09OyKjX4Sik
// for more about this.

assert not find type {
  ctx = []
  exp = Exp::fn("f", Exp::ap(Exp::var("f"), Exp::var("f")))
  Check [ctx, exp, type]
}
